🎥 **Practise Set** [LeetCode 150](https://leetcode.com/studyplan/top-interview-150/)
 
**[1. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150̦)**

_You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, 
representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order._

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {̦
        for(int i =0;i<n;i++)
        {
            nums1[m+i] =  nums2[i] ;
        }
        sort(nums1.begin(),  nums1.end());
    }
};
```
---
**CRUXX to Memorize**
```
if(nums[i] != val)
        {
            nums[k] = nums[i];
            k++ ;
        }
```
**[2. Remove Element](https://leetcode.com/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150)**  

_Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. 
The order of the elements may be changed. Then return the number of elements in nums which are not equal to val._
```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
       int k  = 0 ;
       for(int i = 0; i<nums.size();i++)
       {
        if(nums[i] != val)
        {
            nums[k] = nums[i];
            k++ ;

        }

       }
       return k  ; 
    }
};
```
---
**[3. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)**

_Given an integer array nums sorted in non-decreasing order,
remove the duplicates in-place such that each unique element appears only once. 
The relative order of the elements should be kept the same. Then return the number of unique elements in nums.._
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
      if(nums.empty()) return  0  ;  
      int k = 1 ; 
      for(int i =1 ; i<nums.size() ; i++)
      {
          if(nums[i]!= nums[i-1])
          {
              nums[k]= nums[i] ; 
              k++ ;

          }
      }

      return  k ; 
    }
};
```
---
**[4. Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/)**

_Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.
Return k after placing the final result in the first k slots of nums._
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int k = 2 ;
        if(nums.size()<=2) return nums.size() ; 

        for(int i =2; i<nums.size();i++)
        {
            if(nums[i]!= nums[k-2])
            {
                nums[k]= nums[i] ;
                k++ ;
            }
        }
        return k ;

    }
};
```
---
**[5. Majority Element](https://leetcode.com/problems/majority-element/description/)**

_Given an array nums of size n, return the majority element._  
_The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array._
```cpp
//   Use Map here - Frequency use karna hai
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int ans =0 ; 
        int n = nums.size() ; 
        unordered_map<int,int> mp ;
        for( int i =  0; i <n  ; i++)   //push in mp 
        {
            mp[nums[i]]++ ; 
        }
        for(auto it : nums)             // check in mp
        {
            if(mp[it] > n/2)
            {
                ans = it ; 
            }
        }
        return ans  ; 
    }
};

// 'it' is an object in map mp( here it =  nums[i]), dont forget - loop wale 'i' jaisa number nahi hai.
```
**[6. Rotate Array](https://leetcode.com/problems/rotate-array/description/)**

_Given an integer array nums, rotate the array to the right by k steps, where k is non-negative._

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();

        // nums.insert(nums.end(), nums.begin(), nums.end());

        k = k % n ;
        vector<int> rotated(n);
        for(int i =0;i<n;i++)
        {
            rotated[(i+k)%n] = nums[i]; ///  CATCH ///
        }
        for(int i =0;i<n;i++)
        {
            nums[i]= rotated[i]; 
        }
    }
};
/* Can also do this---

         k = k%n ; 
         reverse(nums.begin(), nums.end());          // Reverse the entire array
         reverse(nums.begin(), nums.begin() + k);    // Reverse first k elements
         reverse(nums.begin() + k, nums.end());      // Reverse the rest

-----------------------------------------------OR----------------------------------------------------------

        k = k % n;
        // Step 1: Create a new array that is nums + nums
        vector<int> temp = nums;
        temp.insert(temp.end(), nums.begin(), nums.end());  //temp is a doubled version of nums
        
        // Step 2: Copy the rotated part back to nums
        for (int i = 0; i < n; i++) {
            nums[i] = temp[n - k + i];
        }
*/

```

---
**[7. Best time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)**

_You are given an array prices where prices[i] is the price of a given stock on the i<sup>th</sup> day.  
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.  
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0._

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0  ;
        int costprice = prices[0];           // Cost Price

        for(int i = 0 ; i< prices.size();i++)
        {
            profit = max(profit, prices[i]- costprice);  //Profit = SP-CP i.e.(prices[i], minprice) ;
            costprice =  min(costprice, prices[i]) ;      // minimising the CP. 
        }
        return profit  ; 
    }
};
```
---
**[8. Best time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/)**

_You are given an integer array prices where prices[i] is the price of a given stock on the i<sup>th</sup> day.  
On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. 
However, you can buy it then immediately sell it on the same day.  
Find and return the maximum profit you can achieve._

```cpp

class Solution {
public:
    int maxProfit(vector<int>& prices) {

        // code easy ch hai...lekin logic strike hona thoda mushkil tha..
        // Logic jaldi hit nahi hota.. better hai keep such questions in mind..
        int profit  = 0  ;
        for(int i  =1 ; i <prices.size(); i++)
        {
            if(prices [i]> prices[i-1])
            {
                profit+= prices[i]-prices[i-1] ;
            }
        }
        return profit ; 
    }

};
```
---
**[9. Jump Game](https://leetcode.com/problems/jump-game/)**

_You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise._

Backward: Start from the end, shrink the goal → elegant and minimal logic.
```cpp

class Solution {
public:
    bool canJump(vector<int>& nums) {
        int goal = nums.size() - 1;

        for (int i = nums.size() - 2; i >= 0; i--) {
            if (i + nums[i] >= goal) {
                goal = i;
            }
        }
        return goal == 0;        
    }
};

========================================================================

//    Forward: At every step, track how far you can jump. If your current index exceeds your maximum reachable index, you can't move forward—game over.
//    Track how far you can go → intuitive and practical.

// bool canJump(vector<int>& nums) {
//     int farthest = 0;
//     for (int i = 0; i < nums.size(); i++) {
//         if (i > farthest) return false;
//         farthest = max(farthest, i + nums[i]);
//     }
//     return true;
// }
```
---
**[10. Jump Game II](https://leetcode.com/problems/jump-game-ii/description/)**

_You are given an array nums, where each element nums[i] represents your maximum jump length from index i._

0 <= j <= nums[i] and i + j < n

_🔹 Goal: Return the minimum number of jumps required to reach the last index._
```cpp

class Solution {
public:
    int jump(vector<int>& nums) {
        // Step 1: Preprocessing - build max reach from each index
        for (int i = 1; i < nums.size(); i++) {
            nums[i] = max( nums[i - 1], nums[i] + i); // pichla wala thik hai, ya ye wla jyada dur ja sakta hai.
        }

        int jumps = 0;
        for (int i = 0; i < nums.size() - 1; i++) {
            jumps++;
            i = nums[i]; // jump to the farthest index reachable from current point
        }

        return jumps;
    }
};

/*
Can also be written as --
for(int i = 0; i < nums.size() - 1; i = nums[i]) {
    jumps++;
}
*/

```
---
**[11. H Index](https://leetcode.com/problems/h-index/description/)**

_Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index._

Sort karna mat bhoolna...highest pehle hona...
```cpp

class Solution {
public:
    int hIndex(vector<int>& citations) {
        int hIndex = 0 ; 
        int n = citations.size() ; 

        sort(citations.begin(), citations.end()) ; 

        for(int i =  n-1 ; i >=0 ; i--)
        {
            if(citations[i]>hIndex) hIndex++ ; 
            
            else
                break ; // this will save useless iteration...
        }

        return hIndex ; 

    }
};

```
---
**[12. Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/description/)**

**RandomizedSet()** : Initializes the RandomizedSet object.  
**bool insert(int val)** : Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.  
**bool remove(int val)** : Removes an item val from the set if present. Returns true if the item was present, false otherwise.  
**int getRandom()** : Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.

_You must implement the functions of the class such that each function works in average O(1) time complexity._
```cpp
class RandomizedSet {


    // do this using a map and a vector 
    // do operations in the vector whereas find/store positions in the map.
    vector<int> v;
    unordered_map<int,int> mp;
public:    
    RandomizedSet() {
    }

    bool search(int val){

         if(mp.find(val)!= mp.end())
            return true;
         return false;

    }

    bool insert(int val) {

        if(search(val))
            return false;

        v.push_back(val);
        mp[val] = v.size()-1; // store the position of 'val'  in map where it was inserted (here it is at the end)
        return true;
    }

    bool remove(int val) {

        if(!search(val))
            return false;   //This prevents trying to remove a non-existent value.
        auto it = mp.find(val);   //Find the iterator pointing to val in the unordered map mp
        v[it->second] = v.back(); //it->second gives the index of val in the vector v //Overwrite the element to be removed with the last element in the vector.
        v.pop_back();
        mp[v[it->second]] = it->second;
        mp.erase(val);
        return true;
    }

// v = [10, 20, 30]
// mp = {10:0, 20:1, 30:2}
// Call remove(20):
// Found 20 at index 1.
// Replace v[1] = v.back() = 30 → v = [10, 30, 30]
// pop_back() → v = [10, 30]
// Update map: mp[30] = 1
// Remove 20 from map → mp = {10:0, 30:1}

    int getRandom() {

        return v[rand()%v.size()];
    }
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet* obj = new RandomizedSet();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */
```
---
**[13. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/description/)**

_Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]._

**The Core Idea:**

 The prefix loop is writing to ans[i] for the first time, so we assign =.  

 The suffix loop is updating ans[i] by multiplying with the suffix, so we use *=.

| Prefix                      | Suffix                               |
| --------------------------- | ------------------------------------ |
| Building from scratch → `=` | Updating what's already there → `*=` |

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n  = nums.size() ; 
        vector<int> ans(n,1) ;     //Division se kaam nai chalega idhar


        int prefix =1 ;
        for(int i = 0 ; i<n;i++)
        {
            ans[i] =prefix ; 
            prefix *= nums[i] ; 
        }
        int suffix =1 ; 
        for(int i =n-1; i>=0 ;i--)
        {
            ans[i] *= suffix ; 
            suffix *=nums[i]; 
        }

        return ans ; 
    }
};

// Your current mistake: product starts at 0 — fix to 1.
// Bigger issue: Division doesn't handle 0s.
// Recommended: Use prefix and suffix product method to solve this properly without division.


```
---
**[14. Gas Station](https://leetcode.com/problems/gas-station/description/)**   [Greedy Problem - need to know context beforehand]

_There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]._  
_You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations._  
_Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.  
If there exists a solution, it is guaranteed to be unique._

```cpp

class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n  = gas.size() ; 
        int start = 0 ; 
        int sumgas = 0 ; 
        int sumcost = 0 ;
        int tank = 0;  
        
        for(int i =0;i<n;i++)            //we want the sum of the gas >= sum of the cost to reach.
        {
            sumgas+= gas[i];
            sumcost+= cost[i]; 
        }
        if(sumgas>= sumcost)
        {
            for(int i= 0 ;i<n;i++)
            {
                tank += gas[i]-cost[i] ;  
                if(tank <0) 
                {
                    tank  = 0 ;         // negative jaye toh tank 0 kar do..
                    start = i+1 ;      // means->“This whole segment didn’t work — start fresh from the next station.”
                }
            }
        }
        else{
            return -1 ; 
        }
        return start ; 

    }
};
```
---
**15. [Candy](https://leetcode.com/problems/candy/description/)**            [Leetcode HARD -- two pass greedy solution] 

_There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.  
You are giving candies to these children subjected to the following requirements:_  
_->Each child must have at least one candy._ | _->Children with a higher rating get more candies than their neighbors._  
Return the minimum number of candies you need to have to distribute the candies to the children.
```cpp
class Solution {
public:
    int candy(vector<int>& arr) {
        int n  = arr.size();  
        vector<int> candies(n,1) ;              // By default single candy ka sum maaro
        // forward pass                         
        for(int i = 1 ; i<n;i++)                
        {
            if(arr[i]>arr[i-1])         //left wala gareeb ho toh ussey jyada
                {
                    candies[i] = candies[i-1]+1 ;
                } 
        }
        ///backward pass ----> isme maximum maintain karo..
        for(int i = n-2 ; i>=0; i--)               // loop chalate time edge cases ka dhyan rakho... out-of-bound nahi jane ka 
        {
            if(arr[i]>arr[i+1])         //right wala gareeb ho toh ussey jyada
            {
                candies[i] = max(candies[i], candies[i+1]+1); 
            }
        }
        //vector ka sum maaro
        int candysum= 0 ; 
        for(int i =0;i<n;i++)
        {
            candysum+= candies[i] ; 
        }
        return candysum ;       
    }
};
//arr[i] agar ameer ho  - toh uske pass aju baju ke gareebo se ek rupaya jyada hi hona chahiye
```
---
**[16. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/description/)**

_Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining._
```
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]  
Output: 6
```
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if (n == 0) return 0;                           //edge condition

        int l = 0, r = n - 1;                           // my two pointers keep in two ends.
        int maxleft = height[l];
        int maxright = height[r];
        int trapped = 0;

        while (l < r) {
          
            if (maxleft <= maxright) {                  //move the left pointer and update trapped water
                l++;
                maxleft = max(maxleft, height[l]);
                trapped += maxleft - height[l];
                  // move pointer after processing
            } 
            else {                                      //move the right pointer and update trapped water
                r--;
                maxright = max(maxright, height[r]);
                trapped += maxright - height[r];
                  // move pointer after processing
            }
        }
        return trapped;
    }
};

```
---
**[17. Roman to Integer](https://leetcode.com/problems/roman-to-integer/description/)**  
_Given a roman numeral, convert it to an integer._  
```
Input: s = "LVIII"  
Output: 58  
Explanation: L = 50, V= 5, III = 3.  
```
```cpp

class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int > mp ; 
                mp['I'] =  1;
                mp['V'] =  5;
                mp['X'] =  10;
                mp['L'] =  50;
                mp['C'] =  100;
                mp['D'] =  500;
                mp['M'] =  1000;


                int result  = 0 ; 
                int n  = s.length(); 

                for(int i = 0 ; i < n-1 ; i++)
                {
                    if(mp[s[i]]<mp[s[i+1]])
                    result-= mp[s[i]]; 
                    else
                    result+= mp[s[i]];
                }
                result+= mp[s[n-1]] ;           // handle the last character seperately. "UNITS wala. catch hai ye".

                return result ; 
    }
};
```
---
**[18. Integer to Roman](https://leetcode.com/problems/integer-to-roman/description/)**
Seven different symbols represent Roman numerals with the following values:  
Symbol	Value  
I	1  
V	5  
X	10  
L	50  
C	100  
D	500  
M	1000  

_Time Complexity:     O(1)_  
_Space complexity:    O(1)_  
One of the most **'OG'** Codes I found on the internet --- Take Notes....
```cpp

using ll = long long;
using ull = unsigned long long;
using ld = long double;
using cd = complex<double>;
using pii = pair<int, int>;
using psi = pair<string,int>;
using pll = pair<ll, ll>;
using ppii = pair<int, pii>;
using vi = vector<int>;
using vd = vector<double>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vll = vector<ll>;
using vvll = vector<vll>;
using vc = vector<char>;
using vpii = vector<pii>;
using vpll = vector<pll>;
using pis = pair<int, string>;
using vs = vector<string>;
using mii = map<int, int>;
using mll = map<ll, ll>;
using umii = unordered_map<int, int>;
using umci = unordered_map<char, int>;
#define pb push_back
#define MOD 1000000007
#define LMOD 1000000000000000007LL
class Solution {
public:
  string intToRoman(int num) {
    vector<psi> mp = {
        {"M", 1000}, {"CM", 900}, {"D", 500}, {"CD", 400}, {"C", 100}, {"XC", 90},  {"L", 50},   {"XL", 40}, {"X", 10},   {"IX", 9}, {"V", 5},    {"IV", 4},   {"I", 1}};
    string ans = "";
    for (auto [s, v] : mp) {
      if (num == 0) break;
      while (num >= v) {
        num -= v;
        ans += s;
      }
    }
    return ans;
  }
};
```
---
**[19. Length of the Last Word](https://leetcode.com/problems/length-of-last-word/description/)**  
```
Input: s = "   fly me   to   the moon  "  
Output: 4  
Explanation: The last word is "moon" with length 4.
```
```cpp
class Solution {
public:
    int lengthOfLastWord(string s) {
        int ans  = 0 ; 

        for(int i =s.length()-1 ; i>=0; i--)
        {
            if(s[i]!=' ') ans++ ; 

            else if(ans > 0) break ; 
        }
        return ans ;
    }
};
```
---
**[20.  Valid Palindrome](https://leetcode.com/problems/valid-palindrome/description/)**  
_Given a string s, return true if it is a palindrome, or false otherwise._  
```
Input: s = "A man, a plan, a canal: Panama"  
Output: true  
Explanation: "amanaplanacanalpanama" is a palindrome.  
```
```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        int i = 0 ;
        int j =  s.length()-1 ; 

        while(i<j)
        {
            while(!isalnum(s[i]) and i<j) i++ ; 

            while(!isalnum(s[j]) and i<j) j-- ;



            if(tolower(s[i])!= tolower(s[j]))  return false ; 


            i++ ;
            j-- ; 
        }

        return true ; 
    }
};

```
```
🤔 So why not just rely on the outer while (i < j)?
Let’s look at a concrete example that shows what can go wrong.
🧪 Edge Case Example: "!!"
This string has only two non-alphanumeric characters.

i = 0, j = 1
Without i < j inside the inner loops:

while (!isalnum(s[i])) i++;  // i becomes 1, then 2 (out of bounds)
while (!isalnum(s[j])) j--;  // j becomes 0, then -1 (out of bounds)
```
---

**[21. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)**

_Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length._  
_Return the indices of the two numbers, index1 and index2, **added by one** as an integer array [index1, index2] of length 2._     
_The tests are generated such that there is exactly one solution. You may not use the same element twice._  
Input: numbers = [2,7,11,15], target = 9  
Output: [1,2]  
Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].  
```cpp
//         Two Pointers Approach

class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int i = 0 ;                         //ptr at start
        int j = numbers.size() -1 ;         //ptr at end 

        vector<int> result ;
        while(i<j)                            // shrink the ptrs from left and right
        {
           int  sum = numbers[i] + numbers[j] ;

            if(sum< target)
            {
                i++ ;
            }
            else if(sum > target)
            {
                j-- ;
            }
            else{
                result.push_back(i+1) ;
                result.push_back(j+1) ;
                break ;
            }

        }    
        return result ;    

    }
};
```
---
**[22. Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/description/)**  [Concept : _stringstream ss(str_name)_ ]
🧠 Key Steps:  
Trim leading/trailing/multiple spaces.  
Split the string into words.  
Reverse the word order.  
Join them back into a string.
```cpp
class Solution {
public:
    string reverseWords(string s) {
        vector<string > words;
        stringstream ss(s) ;
        string word ;
        while(ss >> word)
        {
            words.push_back(word);
        }

        reverse(words.begin(), words.end()) ; 

        string res; 
        string res; 
        for (int i = 0; i < words.size(); i++) {
            if (i > 0) res += " ";  // add space before all except first
            res += words[i];
        }
        return res ; 
    }
};


/*can be also done as --
stringstream ss;      // create empty stringstream
ss << s;              // insert string 's' into the stream 

---

In a range-based for loop:

for (auto it : words)
'it' is not an index. It's a copy of each element (string) in words.

So words[it] doesn't make sense — 'it' is already a word, not a number.
✅ Fix:
Just use res += it; instead.
*/
        // string res;
        // int count = 0;
        // for (auto word : words) 
        // {
        //     if (count++) res += " ";  // add space before all except first
        //     res += word;
        // }
```
---
**[23. Zigzag Conversion](https://leetcode.com/problems/zigzag-conversion/description/)**
```
Example 1:  
Input: s = "PAYPALISHIRING", numRows = 3  
Output: "PAHNAPLSIIGYIR"  

Example 2:  
Input: s = "PAYPALISHIRING", numRows = 4  
Output: "PINALSIGYAHRPI"  
Explanation:  
P     I    N  
A   L S  I G  
Y A   H R  
P     I  

Example 3:  
Input: s = "A", numRows = 1  
Output: "A"  
```
```cpp
class Solution {
public:

    string convert(string s, int numRows) {
    
    if(numRows <= 1) return s;

    vector<string>v(numRows, ""); // Create a vector of (numRows) empty strings.

    int j = 0, direction = -1;

    for(int i = 0; i < s.length(); i++)
    {

        if(j == numRows - 1 || j == 0) direction *= (-1); 
		 
        v[j] += s[i];

        if(direction == 1) j++;

        else j--;
    }

    string res;

    for(auto &it : v) res += it; 

    return res;

    }
};

```
---
**[24. Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)**  
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
```
Example 1:  
Input: haystack = "sadbutsad", needle = "sad"  
Output: 0  
Explanation: "sad" occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.   
Example 2:  
Input: haystack = "leetcode", needle = "leeto"  
Output: -1  
Explanation: "leeto" did not occur in "leetcode", so we return -1.  
```
```cpp
//IDEAL SOLUTION
class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = haystack.length(), m = needle.length();
	//optimization
        if (n < m) return -1;
        int occ = -1;
        for (int i = 0; i <= n - m; i++) {
            if (haystack[i] != needle[0]) continue;
            if (m == 1) return i;
	//mainloop
            int nIdx = 1;
            occ = i;
            for (int j = i + 1; j < n; j++) {
                if (haystack[j] != needle[nIdx]) {
                    occ = -1;
                    break;
                }

                if (nIdx == m - 1) return occ;
                else nIdx++;
            }
        }
        return occ;
    }
};

//using substr, index or find functions can be done easily,
class Solution {
public:
    int strStr(string haystack, string needle) {
        int res ; 
        if (haystack.length() < needle.length()) {
            return -1;
        }
        
        for(int i = 0  ; i< haystack.length() ;i++)
        {
            if (haystack.substr(i, needle.length()) == needle)
            {
                return i ; 
            }
        }

        return -1 ; 
    }
};
```
---
**[25. Is Subsequence](https://leetcode.com/problems/is-subsequence/description/)**  
Given two strings s and t, return true if s is a subsequence of t, or false otherwise.  
```
Example 1:  
Input: s = "abc", t = "ahbgdc"  
Output: true  
Example 2:  
Input: s = "axc", t = "ahbgdc"  
Output: false  
```
```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int i = 0, j = 0 ; 

        while(j<t.length())
        {
            if(s[i]==t[j])
            {
                i++; 
                j++ ;

            }
            else j++ ; 
        }

        if(i ==s.length()) return true ;
        
         return false ;
    }
};
```
---
**[26. Container With Most Water](https://leetcode.com/problems/container-with-most-water/description/)**   
You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).   
Find two lines that together with the x-axis form a container, such that the container contains the most water.   
Return the maximum amount of water a container can store.
```
Input: height = [1,8,6,2,5,4,8,3,7]  
Output: 49  
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.  
Example 2:  
Input: height = [1,1]  
Output: 1  
```
```cpp
//Play with 2 POINTERs 
class Solution {
public:
    int maxArea(vector<int>& height) {
        
        
        int left = 0 ;
        int right = height.size() -1;
        int maxvolume = 0  ; 
        int volume = 0 ;
    
        while(left<right)
        {
            volume = (right-left)* min(height[left],height[right]);
            maxvolume = max(volume,maxvolume) ;

            if(height[left]<=height[right])
            {
                left++ ;
            }
            else{
                right-- ;
            }
	    
        }
        return maxvolume ;       
    }
};
```
---
**[27. 3Sum](https://leetcode.com/problems/3sum/description/)**  
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.  
Notice that the solution set must not contain duplicate triplets.
```cpp
class Solution 
{
public:
    vector<vector<int>> threeSum(vector<int>& nums) 
    {
        vector<vector<int>> result ;
        int n = nums.size() ; 
        //Base case -1
        if(n<3)
        {
            return result ;
        }
        sort(nums.begin() , nums.end()) ;
        
        for(int i = 0 ; i< n-2 ; i++)
        {
            if(i>0 && nums[i-1] == nums[i])continue ;

            int j = i+1 ;
            int k = n-1 ;
            while(j<k)
            {
                int sum = nums[i] + nums[j] + nums[k] ; 

                if(sum<0) j++ ;

                else if(sum >0) k-- ;

                else
                {
                    result.push_back({nums[i],nums[j],nums[k]}) ;

                    while (j < k && nums[j] == nums[j + 1]) 
                    {
                        j++;
                    }
                    j++;
                    
                    while (j < k && nums[k - 1] == nums[k]) 
                    {
                        k--;
                    }
                    k--;
                }
            }
        }
        return result ; 
    }
};
```
---
**[28. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/)**  
Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.  
```
Example 1:
Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.

Example 2:
Input: target = 4, nums = [1,4,4]
Output: 1

Example 3:
Input: target = 11, nums = [1,1,1,1,1]
Output: 0
```
```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int i =0,j = 0, windowSum = 0 ;
        int res =  INT_MAX ;
        
        for(int j =0 ; j<nums.size();j++)
        {
            windowSum+=nums[j] ; 
            while(windowSum >= target)
            {
                res = min(res, j-i+1);
                windowSum -= nums[i] ;
                i++ ; 
            }
        }

        return res == INT_MAX ? 0 : res;
    }
};
```
**[29. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)**  
Given a string s, find the length of the longest substring without duplicate characters.  
```
Example 1:

Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
Example 2:

Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
Example 3:

Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```
```cpp
class Solution {
public:
int lengthOfLongestSubstring(string s) {
    unordered_map<char, int> mp;
    int i = 0, j = 0 ;
    int  maxLen = 0;

    while (j < s.length()) {
        // Add current character to the map
        mp[s[j]]++;

        // If duplicate is found, shrink from the left
        while (mp[s[j]] > 1) {
            mp[s[i]]--;
            if (mp[s[i]] == 0) {
                mp.erase(s[i]);
            }
            i++;
        }
        // Update max length
        maxLen = max(maxLen, j - i + 1);

        j++;
    }

    return maxLen;
}

};
```
**[30. Substring with Concatenation of All Words](https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/)**  
You are given a string s and an array of strings words. All the strings of words are of the same length.  
A concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.  
Return an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.  
```
Example 1:
Input: s = "barfoothefoobarman", words = ["foo","bar"]
Output: [0,9]
Explanation:
The substring starting at 0 is "barfoo". It is the concatenation of ["bar","foo"] which is a permutation of words.
The substring starting at 9 is "foobar". It is the concatenation of ["foo","bar"] which is a permutation of words.

Example 2:
Input: s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
Output: []
Explanation:
There is no concatenated substring.

Example 3:
Input: s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]
Output: [6,9,12]
Explanation:
The substring starting at 6 is "foobarthe". It is the concatenation of ["foo","bar","the"].
The substring starting at 9 is "barthefoo". It is the concatenation of ["bar","the","foo"].
The substring starting at 12 is "thefoobar". It is the concatenation of ["the","foo","bar"].
```
```cpp
//THINK OF SLIDING THE WINDOW WORDWISE --not Alphabetically....

class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> result;
        if (words.empty() || s.empty()) return result;

        int wordLen = words[0].length();
        int wordCount = words.size();
        int windowLen = wordLen * wordCount;
        int n = s.length();

        //push words into the hashmap.
        unordered_map<string, int> wordFreq;
        for (string word : words) wordFreq[word]++;

        // Try every offset within a word length
        for (int i = 0; i < wordLen; i++) {
            int left = i, right = i;
            unordered_map<string, int> seen;

            while (right + wordLen <= n) {
                string word = s.substr(right, wordLen);
                right += wordLen;

                if (wordFreq.find(word) != wordFreq.end()) {
                    seen[word]++;

                    // If word appears too many times, shrink from left
                    while (seen[word] > wordFreq[word]) {
                        string leftWord = s.substr(left, wordLen);
                        seen[leftWord]--;
                        left += wordLen;
                    }

                    // If all words matched
                    if (right - left == windowLen) {
                        result.push_back(left);
                    }
                } else {
                    // Reset window
                    seen.clear();
                    left = right;
                }
            }
        }

        return result;
    }
};
```
---
**[31. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/description/)**  
Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".  
The testcases will be generated such that the answer is unique.  
```
Example 1:
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.

Example 2:
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.

Example 3:
Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.
```
```cpp
class Solution {
public:
    string minWindow(string s, string t) {

        // count of char in string "t".
        unordered_map<char, int> m;
        for (int i = 0; i < t.size(); i++) {
            m[t[i]]++;
        }
        
        int i = 0;
        int j = 0;
        
        // # of chars in t that must be in s
        int counter = t.length();
        
        int minStart = 0;
        int minLength = INT_MAX;
        
        while (j < s.size()) {
            // if char in s exists in t, decrease
            if (m[s[j]] > 0) {
                counter--;
            }
            // if char doesn't exist in t, will be -'ve
            m[s[j]]--;
            // move j to find valid window
            j++;
            
            // when window found, move i to find smaller
            while (counter == 0) {
                if (j - i < minLength) {
                    minStart = i;
                    minLength = j - i;
                }
                
                m[s[i]]++;
                // when char exists in t, increase
                if (m[s[i]] > 0) {
                    counter++;
                }
                i++;
            }
        }
        
        if (minLength != INT_MAX) {
            return s.substr(minStart, minLength);
        }
        return "";
    }
};
```
# 📚 MATRIX
---

**[32. Valid Sudoku](https://leetcode.com/problems/valid-sudoku/description/)**  

Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:  
Each row must contain the digits 1-9 without repetition.  
Each column must contain the digits 1-9 without repetition.  
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.  

**📦 Explanation:**   
**rows[i]** tracks digits seen in the i-th row.   
**cols[j]** tracks digits in the j-th column.  
**boxes[(i // 3) * 3 + (j // 3)]** maps every cell to one of the 9 sub-boxes.  

**unordered_set<char> row[9];** 	--- AN ARRAY of Sets  array({set1},{set2}, {set3} .... {set9}) ; -> one unique set for each row.  
unordered_set<char> row[9];  //unoredred_set datatype cha 9 size cha array pahije.
```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        unordered_set<char> row[9]; 			// is an array of 9 independent sets, each for a different row.
        unordered_set<char> col[9];			// we are using a set of 9 distinct arrays.
        unordered_set<char> box[9];
        for(int i = 0;i<9;i++)
        {
            for(int j =0;j<9;j++)
            {
                char val = board[i][j] ;
                if(val =='.') continue ;

                int boxIndex = (i/3)*3 + (j/3) ;

                // Check duplicates...
                if(row[i].count(val)|| col[j].count(val) || box[boxIndex].count(val))  return false ;

		// Insert if not found...
                row[i].insert(val) ;
                col[j].insert(val) ; 
                box[boxIndex].insert(val) ;
            }
        }

        return true ;
    }
};

/*
int boxIndex = (i/3)*3 + (j/3) ;
This line is key to mapping a cell in a 9×9 grid to its 3×3 sub-box index.
Box Indices:
-------------
| 0 | 1 | 2 |
| 3 | 4 | 5 |
| 6 | 7 | 8 |
-------------
📌 Formula:  int boxIdx = (i / 3) * 3 + (j / 3); 
🧠 Breakdown:
i / 3 gives the box row index (0, 1, or 2)
j / 3 gives the box column index (0, 1, or 2)
Multiply box row by 3, and add box column:
boxIdx = (box_row * 3) + box_col
So for example:

Cell (0,0) → (0/3)*3 + (0/3) = FALLS IN BOX -  0
Cell (4,7) → (4/3)*3 + (7/3) = 1*3 + 2 = FALLS IN BOX - 5
Cell (8,6) → (8/3)*3 + (6/3) = 2*3 + 2 = FALLS IN BOX -  8
*/
```
---

**[33. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/description/)**  
Given an m x n matrix, return all elements of the matrix in spiral order.  
```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]

Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```
```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> result;

        int top = 0;
        int bottom = matrix.size() - 1;
        int left = 0;
        int right = matrix[0].size() - 1;

        while (top <= bottom && left <= right) {
            // left to right
            for (int i = left; i <= right; i++)
                result.push_back(matrix[top][i]);
            top++;

            // top to bottom
            for (int i = top; i <= bottom; i++)
                result.push_back(matrix[i][right]);
            right--;

            // right to left (only if still rows left)
            if (top <= bottom) {
                for (int i = right; i >= left; i--)
                    result.push_back(matrix[bottom][i]);
                bottom--;
            }

            // bottom to top (only if still columns left)
            if (left <= right) {
                for (int i = bottom; i >= top; i--)
                    result.push_back(matrix[i][left]);
                left++;
            }
        }

        return result;
    }
};
```
---
**[34. Rotate Image](https://leetcode.com/problems/rotate-image/description/)**  
<img width="642" height="242" alt="image" src="https://github.com/user-attachments/assets/c4e9d18d-4c44-4655-a630-d232c2c42694" />

```
This implementation rotates an n × n matrix 90° clockwise in-place using two passes:
Flip vertically (swap top & bottom rows).
Transpose across the main diagonal.
Because a vertical flip followed by a transpose == 90° clockwise rotation.


Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
```


```
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int edgeLength = matrix.size();

        int top = 0;
        int bottom = edgeLength - 1;

        // 1) Flip vertically: swap row top ↔ row bottom, move inward
        while (top < bottom) {
            for (int col = 0; col < edgeLength; col++) {
		swap(matrix[top][col], matrix[bottom][col]);
            }
            top++;
            bottom--;
        }

        // 2) Transpose: swap (row,col) ↔ (col,row) for upper triangle only
        for (int row = 0; row < edgeLength; row++) {
            for (int col = row + 1; col < edgeLength; col++) {
                swap(matrix[row][col], matrix[col][row]);
            }
        }        
    }
};

```
